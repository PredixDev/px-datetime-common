<link rel="import" href="../app-localize-behavior/app-localize-behavior.html" />
<script>
/**
  ```validate```

  A collection of validation scripts for px-datetime components

  Dependencies: momentjs

  @polymerBehavior validate
*/

var validate = [Polymer.AppLocalizeBehavior, {
  properties: {
    /**
     * Boolean stating if the current component is valid. Gets updated in '_validateInput'
     *
     * @private
    */
    isValid:{
      type:Boolean,
      value:true,
      notify:true
    },
    /**
     * Boolean stating if the neighbor, dependent component has passed validation
     *
     * Example: 'px-datetime-entry' can be either a date input or a time input. If you want a full date-time, you need both.
     * If 'this' is a time input, you want the neighbor date input to also have passed validation before accepting the full date-time.
     *
     * @private
     */
    neighborValid:{
      type: Boolean,
      value: true
    },
    /**
     * String used to describe the current invalid state
     */
    validationErrorMessage:{
      type: String,
      value: 'invalid'
    },
    /**
     * set a default for localizing
     */
    language: {
      type: String,
      value: 'en'
    },
    /**
     * Use the key for localization if value for  language is missing. Should
     * always be true for px components
     */
    useKeyIfMissing: {
      type: Boolean,
      value: true
    },
    /**
     * used to pass in strings for localization
     */
    resources: {
      type: Object,
      value: function() {
        return {
          'en': {
            'Future dates are not allowed': 'Future dates are not allowed',
            'Past dates are not allowed': 'Past dates are not allowed',
            'Year': 'Year',
            'Month': 'Month',
            'Day': 'Day',
            'Hour': 'Hour',
            'Minute': 'Minute',
            'Second': 'Second',
            'Millisecond': 'Millisecond',
            'is not valid': 'is not valid',
            'This hour is not within a 12 hour clock': 'This hour is not within a 12 hour clock'
          }
        };
      }
    }
  },

  observers: ['_updateValidationEvent(validationErrorMessage)'],

  /**
   * Validation function for 'px-datetime-entry'
   *
   * @return {Boolean} passed validation
   */
  _validateInput: function(showButtons) {
    var inputArr =  Polymer.dom(this.root).querySelectorAll('.cell'),
        invalidObj = new Object();

    // Create a string from all of the fields put together
    inputStr = this._entryInputString(inputArr);
    if (!inputStr){ return false; } // break if incomplete
    inputStr = inputStr.trim();
    inputStr = inputStr.split('\xa0').join(' '); //added to be able to use Moment strict parsing

    inputMoment = Px.moment.tz(inputStr, this.momentFormat, this.timeZone),
    invalidObj.futureSelection    = this.dateOrTime.toLowerCase() === 'date' && this.blockFutureDates && inputMoment.isAfter(Px.moment.tz(Px.moment(), this.timeZone)),
    invalidObj.pastSelection      = this.dateOrTime.toLowerCase() === 'date' && this.blockPastDates  && inputMoment.isBefore(Px.moment.tz(Px.moment(), this.timeZone)),
    invalidObj.pastMaxSelection   = this.dateOrTime.toLowerCase() === 'date' && Object.keys(this.maxDate).length > 0 && inputMoment.isAfter(this.maxDate),
    invalidObj.beforeMinSelection = this.dateOrTime.toLowerCase() === 'date' && Object.keys(this.minDate).length > 0 && inputMoment.isBefore(this.minDate);

    // Validate inputStr
    if((inputMoment.isValid() && !invalidObj.futureSelection && !invalidObj.pastSelection && !invalidObj.pastMaxSelection && !invalidObj.beforeMinSelection)) {
      this.toggleClass('validation-error', false, this.$.wrapper);
      /*
        The input box only has date or time.
        Clone the moment object so we have a full date-time.
        We want to use clone so it stays in utc or local time
      */
      var newMoment = (this.momentObj === undefined) ? Px.moment().tz(this.timeZone) : this.momentObj.clone().tz(this.timeZone);
      // just use the relevant fields, so ok if not in utc timemoment
      var typedInMoment = Px.moment.tz(inputStr, this.momentFormat, this.timeZone);

      // since the input box only has date or time, just reset that portion of the moment object
      if (this.dateOrTime.toLowerCase() === 'date') { // if i'm typing in a date field, set the new date
        newMoment.date(1); // first, 'zero' the date back to the first of the month to prevent any rolling effects (if a month doesn't have 30/31 days)
        newMoment.year(typedInMoment.year()); // set the year
        newMoment.month(typedInMoment.month()); // then the month
        newMoment.date(typedInMoment.date()); // and finally the date, to make sure we don't have any rolling effects
      } else {
        newMoment.hour(typedInMoment.hour());
        newMoment.minute(typedInMoment.minute());
        newMoment.second(typedInMoment.second());
        newMoment.millisecond(typedInMoment.millisecond());
      }

      this.set('isValid', true);
      // if the neighbor is also valid, then we can set our moment object
      if(this.neighborValid && (!this.momentObj || (this.momentObj && !this.momentObj.isSame(newMoment)))) {
        this.fire('px-moment-valid',{'momentObj':newMoment})
      }
      return true;

    } else {
      this._invalidField(this, inputMoment, invalidObj);
      return false;
    }

  },
  /**
   * Validate a complete field
   * called in px-datetime-field and px-datetime-range-field
   *
   * @param {String} funcOrigin - The function that called validation
   * @return validation result
   */
  _validateField: function(funcOrigin) {
    var fieldNodes = new Object(),
        invalidObj = new Object(),
        dateEntry = Polymer.dom(this.root).querySelector('#date'),
        timeEntry = Polymer.dom(this.root).querySelector('#time');
        fieldNodes.dateCells = Polymer.dom(dateEntry.root).querySelectorAll('.cell');
        fieldNodes.timeCells = Polymer.dom(timeEntry.root).querySelectorAll('.cell');

    //Create a string from all of the entries put together
    dateString = this._entryInputString(fieldNodes.dateCells);
    timeString = this._entryInputString(fieldNodes.timeCells);
    if (!dateString || !timeString) {
      return this._handleIncompleteEntries(funcOrigin, dateEntry, fieldNodes);
    }
    dateTimeString = dateString.trim() + " " + timeString.trim();
    dateTimeString = dateTimeString.split('\xa0').join(' '); //added to be able to use Moment strict parsing
    dateTimeFormat = this.dateFormat + " " + this.timeFormat;

    var dateTimeMoment = Px.moment.tz(dateTimeString, dateTimeFormat, this.timeZone);
    invalidObj.futureSelection    = this.blockFutureDates && dateTimeMoment.isAfter(Px.moment.tz(Px.moment(), this.timeZone));
    invalidObj.pastSelection      = this.blockPastDates &&  dateTimeMoment.isBefore(Px.moment.tz(Px.moment(), this.timeZone));
    invalidObj.pastMaxSelection   = Object.keys(this.maxDate).length > 0 && dateTimeMoment.isAfter(this.maxDate);
    invalidObj.beforeMinSelection = Object.keys(this.minDate).length > 0 && dateTimeMoment.isBefore(this.minDate);

    if((dateTimeMoment.isValid() && !invalidObj.futureSelection && !invalidObj.pastSelection && !invalidObj.pastMaxSelection && !invalidObj.beforeMinSelection)) {
      // turn off input box error outline
      dateEntry.toggleClass('validation-error', false, dateEntry.$.fieldWrapper);
      dateEntry.set('isValid', true);

      //if the neighbor is valid, momentObj is undefined or different from current moment obj return the new momentObj
      if(this.neighborValid && (!this.momentObj || (this.momentObj && !this.momentObj.isSame(dateTimeMoment)))) {
        return dateTimeMoment;
      }

    }
    else {
      this._invalidField(dateEntry, dateTimeMoment, invalidObj);
      return false;
    }
  },
  /**
   * Set validation Error Message, turn on validation error, and set isValid to false.
   *
   * @param {Object} dateEntry - px-datetime-entry date
   * @param {Object} submittedMoment - Invalid momentObj
   * @param {Object} invalidObj - Stores the different invalid
   */
  _invalidField: function(dateEntry, submittedMoment, invalidObj) {
    dateEntry.set('validationErrorMessage', this._determineValidationMessage(submittedMoment, invalidObj));
    (this.tagName === "PX-DATETIME-FIELD") ? dateEntry.toggleClass('validation-error', true, this.$.fieldWrapper) : dateEntry.toggleClass('validation-error', true, this.$.wrapper);
    dateEntry.set('isValid', false);
  },
  /**
   * loop through array of the entry cells and return a string of the value
   *
   * @param {Object} cells - Date or time cell nodes
   */
   _entryInputString: function(cells) {
    var outputStr = ""
      for (var i = 0; i < cells.length; i++) {
        var value = Polymer.dom(cells[i].root).querySelector('#dtEntry').value;
        if(value === '') {
          return false;
        }
        if(cells[i].momentFormat !== "Z") {
          outputStr = outputStr + value + cells[i].symbol;
        }
      }
      return outputStr;
  },
  /**
   * Returns a meaningful validation message
   *
   * @param {Object} submittedMoment - Invalid momentObj
   * @param {Object} invalidObj - Stores the different invalid
   */
  _determineValidationMessage: function(submittedMoment, invalidObj) {
    if(!submittedMoment) {
      return this.localize('Incomplete');
    }
    if(invalidObj.futureSelection) {
      return this.localize('Future dates are not allowed');
    }
    else if(invalidObj.pastSelection) {
      return this.localize('Past dates are not allowed');
    }
    else if(invalidObj.pastMaxSelection) {
      return this.localize('Date is past max date');
    }
    else if(invalidObj.beforeMinSelection) {
      return this.localize('Date is before min date');
    }
    else {
      var invalidAt = submittedMoment.invalidAt();

      if(invalidAt !== -1) {
        switch(invalidAt) {
          case 0:
            return this.localize('Year') + ' ' + submittedMoment._a[invalidAt] + ' ' + this.localize('is not valid');
            break;
          case 1:
            return this.localize('Month') + ' ' + (submittedMoment._a[invalidAt] + 1) + ' ' + this.localize('is not valid');
            break;
          case 2:
            return this.localize('Day') + ' ' + submittedMoment._a[invalidAt] + ' ' + this.localize('is not valid');
            break;
          case 3:
            return this.localize('Hour') + ' ' + submittedMoment._a[invalidAt] + ' ' + this.localize('is not valid');
            break;
          case 4:
            return this.localize('Minute') + ' ' + submittedMoment._a[invalidAt]  + ' ' + this.localize('is not valid');
            break;
          case 5:
            return this.localize('Second') + ' ' + submittedMoment._a[invalidAt] + ' ' + this.localize('is not valid');
            break;
          case 6:
            return this.localize('Millisecond') + ' ' + submittedMoment._a[invalidAt] + ' ' + this.localize('is not valid');
            break;
        }
      } else if(submittedMoment.parsingFlags().bigHour === true) {
        return this.localize('This hour is not within a 12 hour clock');
      }
    }
  },
  /**
   * Fires when 'validationErrorMessage' is changed
   *
   * @event px-validation-message
   * @param {string} validationErrorMessage - Values validationErrorMessage
   */
  _updateValidationEvent: function(validationErrorMessage){
    if(validationErrorMessage !== undefined) {
      this.fire('px-validation-message',{'validationErrorMessage': this.validationErrorMessage})
    }
  },
  /**
   * Sets the button state based on if validation has been passed or not. This in turn enables or disables the Submit button.
   *
   * @param {Boolean} state - Where the validation has passed or failed
   */
  _submitButtonState: function(state) {
    this.set('isSubmitButtonValid', state);
  },
  /**
   * If required any incomplete momentObj is invalid
   * If not required determine if the field is blank
   *
   * @param {String} funcOrigin - The function that called validation
   * @param {Element} dateEntry - px-datetime-entry date
   * @param {Object} fieldNodes - Object of date and time cell nodes
   */
   _handleIncompleteEntries: function(funcOrigin, dateEntry, fieldNodes) {
    if (funcOrigin === "_momentChanged") { return false };
    if (!this.required) {
          dateEntryBlank = this._loopOverCellValues(fieldNodes.dateCells);
          timeEntryBlank = this._loopOverCellValues(fieldNodes.timeCells);
      if(dateEntryBlank && timeEntryBlank) {
        dateEntry.toggleClass('validation-error', false, dateEntry.$.fieldWrapper);
        dateEntry.set('isValid', true);
        return "FieldBlank";
      }
      this._invalidField(dateEntry, "", new Object());
    }
    else {
      this._invalidField(dateEntry, "", new Object());
      return false;
    }
  },
  /**
   * Checking to see if all cells are empty
   * If a cell as a value return false
   *
   * @param {Object} cells - Date or time cell nodes
   */
   _loopOverCellValues: function(cells) {
    var isBlank = true;
    for (i = 0; i < cells.length; i++){
      var cellInput = Polymer.dom(cells[i].root).querySelectorAll('#dtEntry');
      if (cellInput[0].value !== "") {
        isBlank = false;
        break;
      }
    };
    return isBlank;
  }
}];


</script>
