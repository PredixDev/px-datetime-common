<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html" />
<link rel="import" href="px-datetime-validate.html" />
<link rel="import" href="px-datetime-behavior.html" />
<link rel="import" href="css/px-datetime-entry-cell-styles.html" />

<!--
Datetime input element. Includes iron-ally-keys-behavior to limit keystrokes to only valid characters.

### Usage

  <px-datetime-entry-cell
    id="cell{{index}}"
    class="cell"
    order='{{index}}'
    moment-obj="[[momentObj]]"
    moment-format='[[item]]'>
  </px-datetime-entry-cell>


@element px-datetime-entry-cell
@homepage index.html
@demo index.html
-->
<dom-module id="px-datetime-entry-cell">
  <template>
    <style include="px-datetime-entry-cell-styles"></style>
    <input
      id="dtEntry"
      order="{{order}}"
      class="text-input--bare"
      on-focus="_handleFocus"
      on-blur="_handleBlur"
      on-paste="_handlePaste"
      on-beforepaste="_beforePaste"
      on-beforecopy="_beforeCopy"
      on-copy="_handleCopy"
      disabled="[[_getDisabled(momentFormat)]]"
      type="[[_getType(momentFormat)]]"
      step="1"
      placeholder="[[_placeholderText(momentFormat)]]" />
    </template>
</dom-module>

<script>
  Polymer({

    is: 'px-datetime-entry-cell',

    behaviors: [
      pxDatetimeBehavior,
      validate,
      Polymer.IronA11yKeysBehavior
    ],

    properties: {
      /**
       * Moment format tokens for the format to display/validate this field against (see http://momentjs.com/docs/#/parsing/string-format/)
       *
       * Can only be configured statically; not data-bindable
       *
       *`example: 'YYYY'`
       *
       * @private
       */
      momentFormat: {
        type: String,
        observer: '_formatChanged'
      },
      /**
       * The separator character, passed down from px-datetime-entry
       *
       * @private
       */
      symbol:{
        type:String
      },
      /**
       * Order number this cell is in px-datetime-entry, passed down from px-datetime-entry
       *
       * @private
       */
      order: {
        type: Number,
        reflectToAttribute: true
      },
      /**
      * Whether the cell is currently selected. Read-only.
      */
      isSelected: {
        type: Boolean,
        readOnly: true,
        notify: true,
        value: false
      }
    },

    observers:[
      '_updateInputValue(momentObj, timeZone)'
    ],

    /**
     * Key bindings for iron-a11y-keys-behavior
     *
     * More keyBindings are added in _addGeneralKeyBindings
     *
     * @private
     */
    keyBindings: {
      'enter' : '_onEnter',
      'right' : '_moveFocusForward',
      'left' : '_moveFocusBack'
    },
    /**
     * On attached, set up key bindings.
     */
    attached: function(){
      this._addGeneralKeyBindings();
    },
    /**
     * Clears the input value for the cell.
     */
    clear: function() {
      this.$.dtEntry.value = '';
    },
    reset: function() {
      this.$.dtEntry.value = this.momentObj.tz(this.timeZone).format(this.momentFormat);
    },
    /**
     *
     */
    _onEnter: function() {
      this._checkValue();
      this._moveFocusForward();
    },
    _getType: function(momentFormat) {
      return (/^(?:a|A|MMM|MMMM|Do|ddd|dddd|Z|ZZ)$/.test(momentFormat)) ? 'text' : 'number';
    },
    /**
     * Disables the input field for time zone entry cells.
     */
    _getDisabled: function(momentFormat) {
      return (this.momentFormat === 'Z' || this.momentFormat === 'ZZ');
    },
    _formatChanged: function() {
      if(this.momentFormat !== undefined) {
        this._updateInputValue();
        this._sizeInputs();
        if(this.$.dtEntry.value) {
          this.cellLength = this.$.dtEntry.value.length;
        }
        else {
          this.cellLength = this.$.dtEntry.placeholder.length;
        }
      }
    },
    /**
     * Size the input fields based on the number of characters in dtWorkingCopy
     */
    _sizeInputs: function(){
      //create a dummy canvas to measure string and make size the input correctly
      var style = window.getComputedStyle(this.$.dtEntry, null),
          fontSize = style.getPropertyValue('font-size'),
          fontFamily = style.getPropertyValue('font-family'),
          c = document.createElement('canvas'),
          ctx=c.getContext('2d'),
          length;

      if(fontSize === "0px" || fontSize === "0" || fontSize === ""){
        setTimeout(function(){
          this._sizeInputs();
        }.bind(this),50);
        return;
      }
      ctx.font = fontSize + " " + fontFamily;
      if(this.$.dtEntry.value) {
        length = ctx.measureText(this.$.dtEntry.value.toUpperCase()).width;
      }
      else {
        length = ctx.measureText(this.$.dtEntry.placeholder.toUpperCase()).width;
      }
      length = Math.ceil(length);
      this.$.dtEntry.style['width'] = length + 'px';
    },
    /**
     * Sets up regular key bindings
     */
    _addGeneralKeyBindings: function(){
      if(this.momentFormat === 'A' || this.momentFormat === 'a'){
        this.addOwnKeyBinding('a p','_toggleAMPM');
        this.addOwnKeyBinding('down up', '_toggleAMPM');
        this.addOwnKeyBinding('backspace del','_preventDeleteDefault');
      } else if(this.momentFormat !== 'Z' && this.momentFormat !== 'ZZ') {
        this.addOwnKeyBinding('1 2 3 4 5 6 7 8 9 0','_digit');
        this.addOwnKeyBinding('down up', '_wraparound');
      }
    },
    /**
     * Sets up separator keybindings
     */
     _addSeparatorKeyBinding: function(){
      var separator = (this.symbol.trim() === '') ? 'space' : this.symbol.trim();
      this.addOwnKeyBinding(separator,'_moveFocusForward');
    },
    /**
     *
     */
    _updateInputValue: function() {
      if(this.momentObj !== undefined && this.timeZone !== undefined) {
        this.reset();

        if(this.momentFormat === 'MMM' || this.momentFormat === 'MMMM') {
          this._sizeInputs();
        }
      }
      else {
        this.$.dtEntry.value = '';
      }
    },
    /**
     * Fires when 'left' key is hit
     *
     * @event px-entry-cell-move
     * @param {number} dir - Values -1
     */
    _moveFocusBack : function(){
      setTimeout(function(){
        this.fire('px-entry-cell-move', { 'dir' : -1 });
      }.bind(this),10);
    },
    /**
     * Fires when 'right' key is hit
     *
     * @event px-entry-cell-move
     * @param {number} dir - Values 1
     */
    _moveFocusForward : function(){
      setTimeout(function(){
        this.fire('px-entry-cell-move', { 'dir' : 1 });
      }.bind(this),10);
    },
    /**
    * Propagate the focus event up to entry to apply inline edit styles if applicable.
    */
    _handleFocus: function(evt) {
      if(this.momentFormat !== 'Z' && this.momentFormat !== 'ZZ') {
        this._setIsSelected(true);
      }
      this.fire('px-cell-focused');
    },
    /**
     * Allow the user to loop through valid cell values
     * ex If the momentFormat is MM the cell value can go from 12 to 1 by hitting the up arrow
     */
    _wraparound: function(evt) {
      var key = evt.detail.combo;
          dtEntryValue = this.$.dtEntry.value;
      if(key === 'up' && (dtEntryValue === "" || parseInt(dtEntryValue) === this._getMax(this.momentFormat))) {
        evt.preventDefault();
        this.$.dtEntry.value = this._getMin(this.momentFormat);
      }
      else if (key === 'down' && (dtEntryValue === "" || parseInt(dtEntryValue) === this._getMin(this.momentFormat))) {
        evt.preventDefault();
        this.$.dtEntry.value = this._getMax(this.momentFormat);
      }
    },
    /**
     * Checks that the value has the correct number of digits for our format
     * Autocomplete function
     */
    _checkValue: function(){
      //if our format requires two digits and we only have one, add a 0 in front
      if(this.$.dtEntry.value && this.$.dtEntry.value.length === 1 &&
       /^(?:MM|DD|HH|hh|kk|mm|ss|YY)$/.test(this.momentFormat)){
        this.$.dtEntry.value =  '0' + this.$.dtEntry.value;
      }
      //if the format is YYYY or Y and the input is 2 characters then convert the input to a 4 character year representation
      else if(this.$.dtEntry.value && this.$.dtEntry.value.length === 2 && this.momentFormat === 'YYYY'){
        var mo = Px.moment(this.$.dtEntry.value, 'YY');
        this.$.dtEntry.value = mo.format(this.momentFormat);
      }
      else if(this.$.dtEntry.value && this.momentFormat[0] === 'S' && this.$.dtEntry.value.length < this.momentFormat.length){
        var dtNumber = parseInt(this.$.dtEntry.value);
        dtNumber = dtNumber.toPrecision(this.momentFormat.length) * Math.pow(10, (this.momentFormat.length - this.$.dtEntry.value.length));
        this.$.dtEntry.value =  dtNumber.toString();
      }
      this._sizeInputs();
    },
    /**
     * Fires on blur
     *
     * @event px-cell-blurred
     */
    _handleBlur: function(evt) {
      var ne = Polymer.dom(evt);
      this._setIsSelected(false);
      this._checkValue();

      this.fire('px-cell-blurred');
    },
    /**
     * get the key that was clicked and add it to the dtWorkingCopy (string displayed in the input)
     */
    _digit: function(evt){
      // if already at full length, we just entered the input, so delete it
      if(this.$.dtEntry.value.length === this.cellLength){
        this.$.dtEntry.value = '';
        this._addSeparatorKeyBinding();
      }
      // if it is full, we're done with this cell, go to the next
      if(this.$.dtEntry.value.length === this.cellLength - 1) {
        this._moveFocusForward();
      }
    },
    /**
     * Toggles AM & PM when up/down or A/P keys are pressed.
     */
    _toggleAMPM : function(evt){
      evt.preventDefault();
      var ne = Polymer.dom(evt),
          key = evt.detail.combo;

      if(key === 'A' || key === 'a'){
        this._setAMPM('AM');
        this._moveFocusForward();

      } else if(key === 'P' || key === 'p'){
        this._setAMPM('PM');
        this._moveFocusForward();

      } else if(key === 'up' || key === 'down'){
        if(this.$.dtEntry.value === 'AM' || this.$.dtEntry.value === 'am'){
          this._setAMPM('PM');
        } else {
          this._setAMPM('AM');
        }
      }
    },
    /**
     * Sets the AM/PM value.
     */
     _setAMPM: function(ampm){
       var mo = Px.moment.tz('01:00:00 ' + ampm, 'hh:mm:ss ' + this.momentFormat, this.timeZone);
       this.$.dtEntry.value = mo.tz(this.timeZone).format(this.momentFormat);
     },
     /**
     * Prevent the delete button from navigating back
     */
    _preventDeleteDefault: function(evt){
      evt.preventDefault();
      this.clear();
    },
    /**
     * If the momentFormat format is not 'Z', 'ZZ', 'X', 'x', 'A' or 'a' then return the momentFormat
     */
    _placeholderText: function(momentFormat){
      var phText = {
        'Z': String.fromCharCode(177) + 'xx:xx',
        'ZZ': String.fromCharCode(177) + 'xxxx',
        'X': 'epoch time (s)',
        'x': 'epoch time (ms)',
        'a': 'AM',
        'A': 'AM'
      };

      if(phText[momentFormat]){
        return phText[momentFormat];
      }
      return momentFormat;
    },
     /**
     * Handles before copy event
     *
     * @event px-request-datetime-entry-copy
     * @param {string} dir - Values clipboardData
     */
     /**
     * Handles before copy event, used for IE instead of the copy event
     */
    _beforeCopy: function(evt) {
      //IE only
      if(!evt.clipboardData) {
        this.fire('px-request-datetime-entry-copy', window.clipboardData);
      }
    },
    /**
     * Handles before paste event, used for IE instead of the paste event
     */
    _beforePaste: function(evt) {
      //IE stores the data in window.clipboardData
      if(!evt.clipboardData) {
        this.fire('px-request-datetime-entry-paste', window.clipboardData);
      }
    },
    /**
     * Handles paste event
     */
    _handlePaste: function(evt){
      //IE stores the data in window.clipboardData and will deal with it on _beforePaste
      if(evt.clipboardData) {
        this.fire('px-request-datetime-entry-paste', evt.clipboardData);
      }
      evt.preventDefault();
    },
    /**
     * Handles copy event
     */
    _handleCopy: function(evt){
      //IE stores the data in window.clipboardData and will deal with it on _beforePaste
      if(evt.clipboardData) {
        this.fire('px-request-datetime-entry-copy', evt.clipboardData);
      }
      evt.preventDefault();
    },
    /**
     * Format strings and setting/modification strings are different (?!?!)
     * This method converts one to the other
     */
    _convertMomentFormat: function(){
      var momentTypeConversion = {
        'Y' : 'y',  //years
        'M' : 'M',  //months
        'D' : 'd',  // days
        'H' : 'h',  //hours
        'h' : 'h',  //hours
        'k' : 'h',  //hours
        'm' : 'm',  //minutes
        's' : 's',  //seconds
        'X' : 's',  //seconds
        'S' : 'ms', //milliseconds
        'x' : 'ms'  //milliseconds
      };
      // take the first char of the moment format and convert it to the other format
      return momentTypeConversion[this.momentFormat[0]]
    },
    /**
     * Set the max value a token can be
     */
    _getMax: function(momentFormat) {
      if( /^(?:M|MM|h|hh)$/.test(momentFormat) ) {
        return 12;
      }
      if( /^(?:D|DD)$/.test(momentFormat) ) {
        return 31;
      }
      if( /^(?:H|HH)$/.test(momentFormat) ) {
        return 23;
      }
      if( /^(?:m|mm|ss|s)$/.test(momentFormat) ) {
        return 59;
      }
      if(momentFormat === "S") {
        return 9;
      }
      if(momentFormat === "SS") {
        return 99;
      }
      if(momentFormat === "SSS") {
        return 999;
      }
      if(momentFormat === "YY") {
        return 99;
      }
      if(momentFormat === "YYYY") {
        return 9999;
      }
    },
    /**
     * Set the min value a token can be
     */
    _getMin: function(momentFormat) {
      if( /^(?:YY|YYYY|X|x|H|HH|m|mm|s|ss|S|SS|SSS)$/.test(momentFormat) ) {
        return 0;
      }
      if( /^(?:M|MM|D|DD|h|hh|k|kk)$/.test(momentFormat) ) {
        return 1;
      }
    }
  });
</script>
